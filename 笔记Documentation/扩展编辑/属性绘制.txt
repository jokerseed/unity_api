属性绘制
借助属性绘制，可以通过使用脚本上的特性或通过控制特定Serializable类的外观来自定义Inspector窗口
中某些控件的外观。
属性绘制有两种途径：
	自定义Serializable类的每个实例的GUI
	通过自定义的属性特性来自定义脚本成员的GUI
	
自定义Serializable类的GUI=================================
如果有自定义的Serializable类，可以使用属性绘制来控制该类在Inspector中的外观。
注意：属性特性类要放在常规脚本文件中
using System;
using UnityEngine;

enum IngredientUnit{Spoon, Cup, Bowl, Piece};

//自定义Serializable类
[Serializable]
public class Ingredient{
	public string name;
	public int amount = 1;
	public IngredientUnit unit;
}

public class Recipe : MonoBehaviour{
	public Ingredient potionResult;
	public Ingredient[] potionIngredients;
}

可以使用自定义属性绘制来更改Inspector中Ingredient类的每个外观。
可以使用CustomPropertyDrawer属性将属性绘制附加到Serializable类，然后传入属性绘制
所针对的Serializable类的类型。

using UnityEditor;
using UnityEngine;

[CustomPropertyDrawer(typeof(Ingredient))]
public class IngredientDrawer : PropertyDrawer{
	//在给定的矩形内绘制属性
	public override void OnGUI(Rect position, SerializabledProperty property, GUIContent label){
		//在父属性上使用
		//BeginProperty/EndProperty意味着预制件重写逻辑作用于整个属性
		EditorGUI.BeginProperty(position, label, property);
		
		//绘制标签
		position = EditorGUI.PrefixLabel(
			position,
			GUIUtility.GetControllD(FocusType.Passive),
			label
		);
		
		//不要让子字段缩进
		var indent = EditorGUI.indentLevel;
		EditorGUI.indentLavel = 0;
		
		// 计算矩形
        var amountRect = new Rect(position.x, position.y, 30, position.height);
        var unitRect = new Rect(position.x + 35, position.y, 50, position.height);
        var nameRect = new Rect(position.x + 90, position.y, position.width - 90, position.height);
        
		// 绘制字段 - 将 GUIContent.none 传入每个字段，从而可以不使用标签来绘制字段
        EditorGUI.PropertyField(amountRect, property.FindPropertyRelative("amount"), GUIContent.none);
        EditorGUI.PropertyField(unitRect, property.FindPropertyRelative("unit"), GUIContent.none);
        EditorGUI.PropertyField(nameRect, property.FindPropertyRelative("name"), GUIContent.none);
		
		// 将缩进恢复原样
        EditorGUI.indentLevel = indent;

        EditorGUI.EndProperty();
	}
}

使用属性特性来自定义脚本成员的GUI===============================
属性绘制的另一用途是更改脚本中具有自定义属性特性的成员的外观。假设要将脚本中的浮点数
或整数限制在特定范围内，并在Inspector中将其显示为滑动条。

//在Inspector中将此浮点数显示为0到10之间的滑动条
[Range(0f, 10f)]
float myFloat = 0f;

还可以创建自己的PropertyAttribute。我们将以RangeAttribute为例。
该属性必须扩展PropertyAttribute类。

using UnityEngine;

public class MyRangeAttribute : PropertyAttribute{
	readonly float min;
	readonly float max;
	
	void MyRangeAttribute(float min, float max){
		this.min = min;
		this.max = max;
	}
}

拥有该特性之后，就需要创建一个属性绘制来绘制具有该属性的属性。该绘制必须扩展PropertyDrawer类，
且必须具有CustomPropertyDrawer特性来说明绘制所针对的特性。

using UnityEditor;
using UnityEngine;

//告知MyRangeDrawer这是针对具有MyRangeAttribute的属性的绘制。
[CustomPropertyDrawer(typeof(MyRangeAttribute))]
public class RangeDrawer : PropertyDrawer{
	//在给定的矩形内绘制属性
	void OnGUI(Rect position, SerializedProperty property, GUIConetnt label){
		//首先获取该特性，因为它包含滑动条的范围
		MyRangeAttribute range = (MyRangeAttribute)attribute;
		
		// 现在根据属性是浮点值还是整数来确定将属性绘制为 Slider 还是 IntSlider。
		if (property.propertyType == SerializedPropertyType.Float)
			EditorGUI.Slider(position, property, range.min, range.max, label);
		else if (property.propertyType == SerializedPropertyType.Integer)
			EditorGUI.IntSlider(position, property, (int) range.min, (int) range.max, label);
		else
			EditorGUI.LabelField(position, label.text, "Use MyRange with float or int.");
	}
}

//////////////注意：出于性能原因，EditorGUILayout函数不能用于属性绘制。